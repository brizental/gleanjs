{"version":3,"sources":["webpack://Glean/webpack/bootstrap","webpack://Glean/./src/constants.js","webpack://Glean/./src/glean.js","webpack://Glean/./src/index.js","webpack://Glean/./src/ping_maker.js","webpack://Glean/./src/private/EventMetricType.js","webpack://Glean/./src/storage.js","webpack://Glean/./src/upload.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;;AAEa;;AAEb,gBAAgB,mBAAO,CAAC,mCAAW;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,+BAAS;AAC/B,wBAAwB,mBAAO,CAAC,mEAA2B;;AAE3D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uCAAa;AACzB,eAAe,mBAAO,CAAC,iCAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,uEAAuE,EAAE;AACzE,6EAA6E;AAC7E;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnRA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA;AACA;AACA;;AAEA,OAAO,sDAAsD,GAAG,mBAAO,CAAC,uCAAa;AACrF,kBAAkB,mBAAO,CAAC,yCAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,wEAAwE,EAAE;AAC1E;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uCAAa;;AAEzB;AACA,6BAA6B,mBAAmB,SAAS,YAAY,YAAY,OAAO;AACxF;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;;AAE/C;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA,+EAA+E,OAAO,iBAAiB,gBAAgB;AACvH;AACA;AACA;AACA,4EAA4E,OAAO,iBAAiB,gBAAgB;AACpH;AACA;AACA,SAAS;AACT;AACA;AACA,oEAAoE,OAAO,+BAA+B,MAAM;AAChH;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA","file":"glean.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nmodule.exports = {\r\n    /**\r\n     * The key to store the last sequence number in storage.\r\n     */\r\n    SEQUENCE_NUMBER_STORAGE_KEY: \"gleanSequenceNumber\",\r\n\r\n    /**\r\n     * The key to store the time the last ping was sent in storage.\r\n     */\r\n    LAST_SENT_DATE_KEY: \"gleanLastSentDate\",\r\n    \r\n    /**\r\n     * The key to store the client id.\r\n     */\r\n    CLIENT_ID_KEY: \"gleanClientId\",\r\n    \r\n    /**\r\n     * The key to store the first run date.\r\n     */\r\n    FIRST_RUN_DATE_KEY: \"gleanFirstRunDate\",\r\n\r\n    /**\r\n     * The key to store the pending ping payloads.\r\n     */\r\n    PENDING_PINGS_STORAGE_KEY: \"gleanPendingPings\",\r\n    \r\n    /**\r\n     * The key to store glean events on localStorage.\r\n     */\r\n    EVENT_STORAGE_KEY: \"gleanEvents\",\r\n    \r\n    /**\r\n     * The maximum number of events to hold until it's time to flush.\r\n     */\r\n    MAX_EVENTS: 10,\r\n    \r\n    /**\r\n     * The interval in which to batch and send events.\r\n     */\r\n    EVENTS_PING_INTERVAL: 60 * 1000, // 5s\r\n\r\n    /**\r\n     * The current version of this SDK,\r\n     * this must by in sync with the version in the package.json.\r\n     *\r\n     * TODO: Find a better way to get this.\r\n     */\r\n    TELEMETRY_SDK_BUILD: \"0.0.1\",\r\n\r\n    /**\r\n     * The telemetry endpoint to send data to.\r\n     */\r\n    TELEMETRY_ENDPOINT: \"https://cors-anywhere.herokuapp.com/https://incoming.telemetry.mozilla.org/\",\r\n\r\n    /**\r\n     * The amount of time to wait before retrying on a recoverable error.\r\n     */\r\n    RECOVERABLE_UPLOAD_ERROR_TIMEOUT: 60 * 1000, // 1min\r\n}\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\n\"use strict\";\r\n\r\nconst Storage = require('./storage');\r\n\r\nclass Glean {\r\n  constructor() {\r\n    console.log(\"Initialize\");\r\n\r\n    let appId = null;\r\n    // Chrome does not define the `browser` object. Instead, it defines\r\n    // the `chrome` object.\r\n    var browser = browser || chrome;\r\n    if (browser) {\r\n      console.log(\"Running from a webextension\");\r\n      appId = browser.runtime.id;\r\n    } else if (gleanScript) {\r\n      console.log(\"Running from a web page\");\r\n      let gleanScript = document.querySelector('[src*=glean\\\\.js]');\r\n      appId = gleanScript && gleanScript.getAttribute('app-id');\r\n    }\r\n\r\n    if (appId == null || appId.length == 0) {\r\n      console.error(\"Unable to initialize Glean.JS: no app id provided.\");\r\n      return;\r\n    }\r\n\r\n    this._eventStorage = new Storage(appId);\r\n  }\r\n}\r\n\r\nmodule.exports = new Glean();\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nconst glean = require(\"./glean\");\r\nconst EventMetricType = require(\"./private/EventMetricType\");\r\n\r\nmodule.exports = {\r\n    INSTANCE: glean,\r\n    _MetricTypes: {\r\n        EventMetricType\r\n    }\r\n};\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nconst {\r\n    PENDING_PINGS_STORAGE_KEY,\r\n    CLIENT_ID_KEY,\r\n    FIRST_RUN_DATE_KEY,\r\n    SEQUENCE_NUMBER_STORAGE_KEY,\r\n    LAST_SENT_DATE_KEY,\r\n    TELEMETRY_SDK_BUILD,\r\n} = require(\"./constants\");\r\nconst upload = require(\"./upload\");\r\n\r\n/**\r\n * A helper class to collect and send pings for uploading.\r\n */\r\nclass PingMaker {\r\n    constructor(appId) {\r\n        // Have a mirror of the pings persisted in storage\r\n        // so we don't need to make that trip everytime.\r\n        this._pings = this._getPersistedPings();\r\n        this._appId = appId;\r\n        // Preload all the info that doesn't change.\r\n        this._clientId = this._getClientId();\r\n        this._firstRunDate = this._getFirstRunDate();\r\n\r\n        const { os, browser, deviceType } = this._getPlatformInfo();\r\n        this._os = os;\r\n        // TODO: Where should we add these in the client_info for now?\r\n        this._browser = browser;\r\n        this._deviceType = deviceType;\r\n\r\n        // Locale could actually change between pings,\r\n        // but I think we can ignore that for now.\r\n        try {\r\n            this.locale = navigator.language;\r\n        } catch {\r\n            this.locale = \"und\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the ping payload and submission url,\r\n     * saves it to storage and triggers upload.\r\n     *\r\n     * @param {String} events A JSON encoded string with the events payload\r\n     *\r\n     * @returns {String} The ping payload (adding this here just until we got the uploader)\r\n     */\r\n    collect(events) {\r\n        const pingId = this._getUUIDv4();\r\n        const pingBody = {\r\n            client_info: this._buildClientInfo(),\r\n            ping_info: this._buildPingInfo(),\r\n            events,\r\n        };\r\n\r\n        this._pushPing(pingId, pingBody);\r\n\r\n        // Trigger upload for the newly collected ping\r\n        upload(pingId, pingBody);\r\n    }\r\n\r\n    /**\r\n     * Get the persisted pings from storage.\r\n     *\r\n     * @returns {String[]} The parsed array of pings found in storage or an empty array.\r\n     */\r\n    _getPersistedPings() {\r\n        let persisted = localStorage.getItem(PENDING_PINGS_STORAGE_KEY);\r\n        if (!persisted) {\r\n            return {};\r\n        }\r\n\r\n        try {\r\n            let parsed = JSON.parse(persisted);\r\n            return parsed;\r\n        } catch(e) {\r\n            console.error(`Unable to parse Glean pings from storage: ${e}`);\r\n            localStorage.setItem(PENDING_PINGS_STORAGE_KEY, JSON.stringify({}));\r\n            return {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new ping to storage.\r\n     *\r\n     * @param {String} pingId The id of the ping to persist\r\n     * @param {Object} pingBody Te body of the ping to persist\r\n     */\r\n    _pushPing(pingId, pingBody) {\r\n        this._pings[pingId] = pingBody;\r\n        localStorage.setItem(PENDING_PINGS_STORAGE_KEY, JSON.stringify(this._pings));\r\n    }\r\n\r\n    /**\r\n     * Build the ping info section of the ping.\r\n     */\r\n    _buildPingInfo() {\r\n        let { startTime, endTime } = this._getStartEndTimes();\r\n        return {\r\n            seq: this._getNextSequenceNumber(),\r\n            experiments: {},\r\n            start_time: startTime,\r\n            end_time: endTime,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the client info section of the ping.\r\n     */\r\n    _buildClientInfo() {\r\n        return {\r\n            app_build: \"Unknown\",\r\n            app_display_version: \"Unknown\",\r\n            architecture: \"Unknown\",\r\n            client_id: this._clientId,\r\n            first_run_date: this._firstRunDate,\r\n            os: this._os,\r\n            os_version: \"Unknown\",\r\n            telemetry_sdk_build: TELEMETRY_SDK_BUILD,\r\n            locale: this.locale\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the client id from storage or create a new one and store it.\r\n     *\r\n     * @returns {String} The stored client_id.\r\n    */\r\n    _getClientId() {\r\n        let stored = localStorage.getItem(CLIENT_ID_KEY);\r\n        if (!stored) {\r\n            let newClientId = this._getUUIDv4();\r\n            localStorage.setItem(CLIENT_ID_KEY, newClientId);\r\n            return newClientId;\r\n        } else {\r\n            // TODO: Validate that the stored value is a UUIDv4.\r\n            return stored;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the first run date from storage or create a new one and store it.\r\n     *\r\n     * @returns {String} The stored first run date.\r\n    */\r\n    _getFirstRunDate() {\r\n        let stored = localStorage.getItem(FIRST_RUN_DATE_KEY);\r\n        if (!stored) {\r\n            let firstRunDate = (new Date()).toISOString();\r\n            localStorage.setItem(FIRST_RUN_DATE_KEY, firstRunDate);\r\n            return firstRunDate;\r\n        } else {\r\n            return stored;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the next sequence number and updates localStorage with it.\r\n     *\r\n     * @returns {Number} The next sequence number.\r\n    */\r\n    _getNextSequenceNumber() {\r\n        let stored = parseInt(localStorage.getItem(SEQUENCE_NUMBER_STORAGE_KEY));\r\n        let nextSequenceNumber;\r\n        if (isNaN(stored)) {\r\n            nextSequenceNumber = 1;\r\n        } else {\r\n            nextSequenceNumber = stored + 1;\r\n        }\r\n        localStorage.setItem(SEQUENCE_NUMBER_STORAGE_KEY, nextSequenceNumber);\r\n        return nextSequenceNumber;\r\n    }\r\n\r\n    /**\r\n     * Get the last sent date from storage and gets the current date,\r\n     * the former is the start time and the latter is the end time.\r\n     *\r\n     * @returns {Object} An object holding start and end times.\r\n     */\r\n    _getStartEndTimes() {\r\n        let startTime = localStorage.getItem(LAST_SENT_DATE_KEY);\r\n        if (!startTime) {\r\n            startTime = (new Date()).toISOString();\r\n        }\r\n\r\n        let endTime = (new Date()).toISOString();\r\n        localStorage.setItem(LAST_SENT_DATE_KEY, endTime);\r\n        return {\r\n            startTime,\r\n            endTime,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Best effort to try and get os, browser and device type from UserAgent string.\r\n     *\r\n     * @returns {Object} And object holding the guessed os, browser and device types.\r\n     */\r\n    _getPlatformInfo() {\r\n        function _guessOS(ua) {\r\n            if (ua.indexOf(\"win\") != -1) {\r\n                return \"Windows\";\r\n            } else if (ua.indexOf(\"mac\") != -1) {\r\n                return \"MacOS\";\r\n            } else if (ua.indexOf(\"linux\") != -1 ) {\r\n                return \"Linux\";\r\n            } else if (ua.indexOf(\"ios\") != -1) {\r\n                return \"iOS\";\r\n            } else if (ua.indexOf(\"android\") != -1) {\r\n                return \"Android\";\r\n            }\r\n\r\n            return \"Unknown\";\r\n        }\r\n\r\n        function _guessBrowser(ua) {\r\n            if (ua.indexOf(\"firefox\") != -1) {\r\n                return \"Firefox\";\r\n            } else if (ua.indexOf(\"opera\") != -1) {\r\n                return \"Opera\";\r\n            } else if (ua.indexOf(\"chrome\") != -1 ) {\r\n                return \"Chrome\";\r\n            } else if (ua.indexOf(\"safari\") != -1) {\r\n                return \"Safari\";\r\n            } else if (ua.indexOf(\"edge\") != -1) {\r\n                return \"Edge\";\r\n            } else if (ua.indexOf(\"ie\") != -1) {\r\n                return \"IE\";\r\n            }\r\n\r\n            return \"Unknown\";\r\n        }\r\n\r\n        function _guessDeviceType(ua) {\r\n            if (ua.indexOf(\"tablet\") != -1) {\r\n                return \"Tablet\";\r\n            }\r\n\r\n            if (ua.indexOf(\"android\") != -1) {\r\n                if (ua.indexOf(\"mobi\") != -1) {\r\n                return \"Mobile\";\r\n                } else {\r\n                // If it's Android and is not a phone, it's probably a tablet.\r\n                return \"Tablet\";\r\n                }\r\n            }\r\n\r\n            return \"Desktop\";\r\n        }\r\n\r\n        // TODO: we should really have some \"PlatformInfo\" class that uses\r\n        // UA when in a webpage and the WebExtentions APIs when in an addon.\r\n        const ua = navigator.userAgent.toLowerCase();\r\n        return {\r\n            os: _guessOS(ua),\r\n            browser: _guessBrowser(ua),\r\n            deviceType: _guessDeviceType(ua),\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is shamelessly copied from https://stackoverflow.com/a/2117523/261698\r\n     *\r\n     * @returns {String} A randomly generated UUIDv4.\r\n     */\r\n    _getUUIDv4() {\r\n        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\r\n            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\r\n        );\r\n    }\r\n}\r\n\r\nmodule.exports = PingMaker\r\n\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nconst glean = require('../glean');\r\n\r\nclass EventMetricType {\r\n  constructor(category, name) {\r\n    this.category = category;\r\n    this.name = name;\r\n  }\r\n\r\n  async record(extra) {\r\n    glean._eventStorage.record(Date.now(), this.category, this.name, extra);\r\n  }\r\n}\r\n\r\nmodule.exports = EventMetricType;\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nconst { EVENT_STORAGE_KEY, MAX_EVENTS, EVENTS_PING_INTERVAL } = require(\"./constants\");\r\nconst PingMaker = require(\"./ping_maker\");\r\n\r\n/**\r\n * Represents the recorded data for a single event.\r\n */\r\nclass RecordedEvent {\r\n    /**\r\n     * Creates a new RecordedEvent.\r\n     *\r\n     * @param {Number} timestamp The timestamp of when the event was recorded. This allows to order events from a single process run.\r\n     * @param {String} category The event's category. This is defined by users in the metrics file.\r\n     * @param {String} name The event's name. This is defined by users in the metrics file.\r\n     * @param {Object} extra A map of all extra data values. The set of allowed extra keys is defined by users in the metrics file.\r\n     */\r\n    constructor(timestamp, category, name, extra) {\r\n        this.timestamp = timestamp;\r\n        this.category = category;\r\n        this.name = name;\r\n        this.extra = extra;\r\n    }\r\n\r\n    /**\r\n     * Serialize an event to JSON, adjusting its timestamp relative to a base timestamp.\r\n     *\r\n     * @param {Number} timestampOffset\r\n     *\r\n     * @returns {String} A JSON encoded string representing the serialized event.\r\n     */\r\n    serializeRelative(timestampOffset) {\r\n        return {\r\n            timestamp: this.timestamp - timestampOffset,\r\n            category: this.category,\r\n            name: this.name,\r\n            extra: this.extra\r\n        };\r\n    }\r\n}\r\n\r\nclass Storage {\r\n    /**\r\n     * Creates a new storage.\r\n     *\r\n     * @param {String} appId The app id where this instance of Glean is running\r\n     */\r\n    constructor(appId) {\r\n        // Create an instance of the pingMaker to collect event when necessary.\r\n        this._pingMaker = new PingMaker(appId);\r\n        // Have a mirror of the events persisted in storage\r\n        // so we don't need to make that trip everytime.\r\n        this._events = this._getPersistedEvents();\r\n        // The first event we get will be sent immediatelly,\r\n        // other will be sent when MAX_EVENTS is reached or when we reach the end of an interval.\r\n        this._atFirstEvent = true;\r\n        // Set up an interval to send evenst periodically\r\n        // TODO: Make sure using setInterval is not a terrible idea\r\n        this._interval = setInterval(this._collectEvents, EVENTS_PING_INTERVAL);\r\n\r\n        // If persisted events have reached limit, submit them\r\n        if (this._events.length >= MAX_EVENTS) {\r\n            this._collectEvents();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Records a new event in storage.\r\n     *\r\n     * @param {Number} timestamp The timestamp of when the event was recorded. This allows to order events from a single process run.\r\n     * @param {String} category The event's category. This is defined by users in the metrics file.\r\n     * @param {String} name The event's name. This is defined by users in the metrics file.\r\n     * @param {Object} extra A map of all extra data values. The set of allowed extra keys is defined by users in the metrics file.\r\n     */\r\n    record(timestamp, category, name, extra) {\r\n        this._pushEvent(new RecordedEvent(timestamp, category, name, extra));\r\n\r\n        if (this._atFirstEvent) {\r\n            this._collectEvents();\r\n            this._atFirstEvent = false;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Collects currently stored events for uploading and clears storage.\r\n     */\r\n    _collectEvents() {\r\n        if (this._events && this._events.length > 0) {\r\n            // Do the actual collection\r\n            this._pingMaker.collect(this._snapshot())\r\n            // Clear stores\r\n            this._events = []\r\n            localStorage.setItem(EVENT_STORAGE_KEY, JSON.stringify(this._events));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a snapshot of the current events.\r\n     *\r\n     * @returns {Object} An representing all events stored, with timestamps relative to the first event.\r\n     */\r\n    _snapshot() {\r\n        let snapshot = [];\r\n        const firstTimestamp = this._events && this._events[0].timestamp;\r\n        for (const event of this._events) {\r\n            snapshot.push(event.serializeRelative(firstTimestamp));\r\n        }\r\n        return snapshot;\r\n    }\r\n\r\n    /**\r\n     * Adds a new event to `this._events` and triggers ping collection\r\n     * in case MAX_EVENTS has been reached.\r\n     *\r\n     * @param {RecordedEvent} event The event to persist\r\n     */\r\n    _pushEvent(event) {\r\n        this._events.push(event);\r\n        localStorage.setItem(EVENT_STORAGE_KEY, JSON.stringify(this._events));\r\n\r\n        if (this._events.length >= MAX_EVENTS) {\r\n            this._collectEvents();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the persisted events from storage.\r\n     *\r\n     * @returns {String[]} The parsed array of events found in localStorage or an empty array.\r\n     */\r\n    _getPersistedEvents() {\r\n        let persisted = localStorage.getItem(EVENT_STORAGE_KEY);\r\n        if (!persisted) {\r\n            return [];\r\n        }\r\n\r\n        try {\r\n            let parsed = JSON.parse(persisted);\r\n            return parsed.map(e => new RecordedEvent(e));\r\n        } catch(e) {\r\n            console.error(`Unable to parse Glean events from storage: ${e}`);\r\n            localStorage.setItem(EVENT_STORAGE_KEY, JSON.stringify([]));\r\n            return [];\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Storage\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\nconst {\r\n    TELEMETRY_ENDPOINT,\r\n    PENDING_PINGS_STORAGE_KEY,\r\n    RECOVERABLE_UPLOAD_ERROR_TIMEOUT\r\n} = require(\"./constants\");\r\n\r\nasync function upload(pingId, payload) {\r\n    const submissionUrl = `${TELEMETRY_ENDPOINT}submit/${this._appId}/events/1/${pingId}`;\r\n    const request = {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application/json; charset=utf-8\",\r\n            \"Date\": (new Date()).toISOString(),\r\n            \"X-Client-Type\": \"Glean.JS\",\r\n            \"X-Client-Version\": \"0.0.1\",\r\n            \"X-Debug-ID\": \"ninja-dx-webext\"\r\n        },\r\n        body: JSON.stringify(payload),\r\n        mode: \"cors\",\r\n        cache: \"default\"\r\n    };\r\n\r\n    console.info(`Sending a new ping! ${pingId}\\n`, JSON.stringify(request, null , 2));\r\n\r\n    fetch(submissionUrl, request)\r\n        .then(response => {\r\n            switch (true) {\r\n                // Success case\r\n                case response.status >= 200 && response.status < 300:\r\n                    console.info(`Ping submitted successfully ${pingId}`);\r\n                    _deletePersistedPing(pingId);\r\n                    break;\r\n                // Unrecoverable error case\r\n                case response.status >= 400 && response.status < 500:\r\n                    console.error(`Unrecoverable error while submitting ping ${pingId}. Status code: ${response.status}`);\r\n                    break;\r\n                // Recorevable error case\r\n                default:\r\n                    console.warn(`Recoverable error while submitting ping ${pingId}. Status code: ${response.status}`);\r\n                    setTimeout(() => upload(pingId, payload), RECOVERABLE_UPLOAD_ERROR_TIMEOUT);\r\n            }\r\n        })\r\n        .catch(error => {\r\n            // These are always recoverable since they are errors while trying to make the request.\r\n            console.warn(`Recoverable error while submitting ping ${pingId}. Unable to perform request: ${error}`);\r\n            setTimeout(() => upload(pingId, payload), RECOVERABLE_UPLOAD_ERROR_TIMEOUT);\r\n        });\r\n}\r\n\r\n// TODO: This should really go in a shared \"Storage\" module used by both ping_maker and\r\n// upload.\r\nfunction _deletePersistedPing(pingId) {\r\n    console.info(`Deleting ping ${pingId} from storage`);\r\n    let pings = JSON.parse(localStorage.getItem(PENDING_PINGS_STORAGE_KEY)) || {};\r\n    delete pings[pingId];\r\n    localStorage.setItem(PENDING_PINGS_STORAGE_KEY, JSON.stringify(pings));\r\n}\r\n\r\nmodule.exports = upload\r\n"],"sourceRoot":""}